#include "memory.h"
#include "stddef.h"
#include "string.h"

#include <api/term.h>
#include <api/color.h>

#define LIBC_MEMORY_MAGIC 0xFACC0FF

typedef struct  {
    uintptr_t before;
    size_t size;
    bool allocated;

    // we keep this to check if the block is valid or not
    uint32_t magic;
} __block_header_t;

uint8_t* memory_start_address;
__block_header_t* first_free_block;
// __block_header_t* last_memory_block;

__block_header_t* __get_block_header(void* ptr);
__block_header_t* __get_next_block(__block_header_t* curr, bool create);
__block_header_t* __merge_empty_blocks(__block_header_t* block);
__block_header_t* __get_next_free_block(__block_header_t* curr);

void kernel_memory_init() {
	char buf[16];
	buf[0] = '0';
	buf[1] = 'x';

	itoa(sizeof(__block_header_t), buf + 2, 16);
	term_write("size of block header: ");
	term_write(buf);
	term_write("\n");

    memory_start_address = (uint8_t*)0x10000;
    first_free_block = (__block_header_t*)memory_start_address;
    first_free_block->allocated = false;
	first_free_block->before = NULL;
	first_free_block->magic = LIBC_MEMORY_MAGIC;

    // cause we can use this as much as we want technically
    // I probably should add memory detection and set it to that
    first_free_block->size = 0xffff;

    // last_memory_block = nullptr;
}

void* malloc(size_t size) {
	char buf[16];
	buf[0] = '0';
	buf[1] = 'x';

	term_write("allocation size ");
	itoa(size, buf + 2, 16);
	term_write(buf);
	term_write("\n");

    if(size == 0) {
        return NULL;
    }

    __block_header_t* block = first_free_block;
    do {
		term_write("\tBlock with size ");
		itoa(block->size, buf + 2, 16);
		term_write(buf);
		term_write("\n");

        // do we have enough space?
        if(block->size >= size) {
            // we found a good block!

            // Do we have space for another full block?
            if(block->size - size > sizeof(__block_header_t)) {
				// save the original block size
				size_t originalBlockSize = block->size;

				// we change the current buffer size
				block->size = size;

                // lets create a new sub block
                __block_header_t* newblock = __get_next_block(block, true);
                newblock->allocated = false;
                newblock->magic = LIBC_MEMORY_MAGIC;
                newblock->size = originalBlockSize - size;

				term_write("\tCreating sub block ");
				itoa(newblock->size, buf + 2, 16);
				term_write(buf);
				term_write("\n");

				// the new allocated block
                newblock->before = (uintptr_t)block;

				// the old next
                __block_header_t* oldNext = __get_next_block(block, false); 

                // is there a block after this one?
                if(oldNext != nullptr) {
                    // insert the new sub block
                    oldNext->before = (uintptr_t)newblock;
				}

				// is our block the last memory block?
				//if (newblock > last_memory_block) {
				//	last_memory_block = newblock;
				//}
			}

            // is this the first free block? 
            if(block == first_free_block) {
				term_write("this is the first free block.\n");
                // update it!
                first_free_block = __get_next_free_block(block);
            }
			
            // block is allocated! return the pointer to it!
            block->allocated = true;
			void* newPtr = (void*)((uintptr_t)block + sizeof(__block_header_t));
			*((int*)newPtr) = 0xdeadbeaf;
			return newPtr;
        }

        block = __get_next_free_block(block);
    }while(block != nullptr);

    // wut? probably ran out of space
    return nullptr;
}

bool free(void* ptr) {
	__block_header_t* block = __get_block_header(ptr);
	if (block == nullptr) {
		return false;
	}
    block->allocated = false;

	//if (block == last_memory_block) {
	//	last_memory_block = (__block_header_t*)block->before;
	//}

	block = __merge_empty_blocks(block);

    if(first_free_block < block) {
        first_free_block = block;
    }
    return true;
}

void* realloc(void* ptr, size_t newsize) {
	__block_header_t* oldBlock = __get_block_header(ptr);
	if (oldBlock == nullptr) {
		return malloc(newsize);
	}
	size_t oldSize = oldBlock->size;
	free(ptr);
	void* newPtr = malloc(newsize);
	memcpy(newPtr, ptr, oldSize);
	return newPtr;
}

////////////////////////////////////////////////////////////

__block_header_t* __get_next_block(__block_header_t* curr, bool create) {
	__block_header_t* block = (__block_header_t*)(curr + sizeof(__block_header_t) + curr->size);
	if (!create && block->magic != LIBC_MEMORY_MAGIC) {
		return nullptr;
	}
	return block;
}

// merge empty blocks, return the new base block
__block_header_t* __merge_empty_blocks(__block_header_t* block) {
	// first we check if we can merge with the next one
	__block_header_t* next = __get_next_block(block, false);
	if (next != nullptr && !next->allocated) {
		// the block is empty, lets merge them
		// we need to update the before of that block
		__block_header_t* nextnext = __get_block_header(next);
		nextnext->before = (uintptr_t)block;

		// set the new size
		block->size += sizeof(__block_header_t) + next->size;

		// invalidate the merged block, just incase
		next->size = 0;
		next->magic = 0;
	}

	// now we take the block before us and attempt to do the same
	__block_header_t* before = (__block_header_t*)block->before;
	if (before != nullptr && !before->allocated) {
		// we have a block before us that is empty? attempt to merge and return it's block
		return __merge_empty_blocks(before);
	}

	// no empty block before us? just return the current block
	return block;
}

__block_header_t* __get_next_free_block(__block_header_t* curr) {
	do {
		curr = __get_next_block(curr, false);
	} while (curr != nullptr && !curr->allocated);
	return curr;
}

__block_header_t* __get_block_header(void* ptr) {
	if (ptr == nullptr) {
		// Invalid pointer
		return nullptr;
	}
	/*if (((uintptr_t)last_memory_block + sizeof(__block_header_t)) < (uintptr_t)ptr) {
		// Invalid pointer
		return nullptr;
	}*/
	__block_header_t* block = (__block_header_t*)((uintptr_t)ptr - sizeof(__block_header_t));
	if (block->magic != LIBC_MEMORY_MAGIC) {
		// Invalid block
		return nullptr;
	}
	return block;
}

